#include <iostream> using namespace std; class AQueue { int queue; int *reverseQueue; int maxSize; int front; int rear; int reversedFront; int reversedRear; public: AQueue() {} AQueue(int size) { maxSize = size; queue = new int[maxSize]; reverseQueue = new int[maxSize]; front = -1; rear = -1; reversedFront = -1; reversedRear = -1; } bool isEmpty() { return front == -1 && rear == -1; } bool isFull() { return rear == maxSize - 1; } bool reversedQueueIsEmpty() { return reversedFront == -1 && reversedRear == -1; } void enQueue(int anElement) { if (rear == maxSize - 1) { cout << "!! THE QUEUE IS FULL !!" << endl; } else if (front == -1 && rear == -1) { front = 0; rear = 0; queue[rear] = anElement; } else { rear++; queue[rear] = anElement; } } void reversedEnQueue(int anElement) // Stack top // push { if (reversedFront == maxSize - 1) { cout << "!! THE QUEUE IS FULL !!" << endl; } else if (reversedFront == -1 && reversedRear == -1) { reversedFront = 0; reversedRear = 0; reverseQueue[reversedRear] = anElement; } else { reversedRear++; reverseQueue[reversedRear] = anElement; } } void reverseDeQueue() // Checking the queue is empty or not // Pop { if (reversedFront == -1 && reversedRear == -1) { cout << "!! THE QUEUE IS EMPTY !!" << endl; } else if (reversedFront == reversedRear && reversedFront != -1) // { reversedFront = -1; reversedRear = -1; } else reversedFront++; } void deQueue() // if we call dequeue then it will call pop { for (int count = rear; count >= front; count--) { reversedEnQueue(queue[count]); } for (int count = front; count <= rear; count++) { queue[count] = reverseQueue[count]; } while (!reversedQueueIsEmpty()) { reverseDeQueue(); } if (front == rear && front != -1) { front = -1; rear = -1; } else front++; for (int count = rear; count >= front; count--) { reversedEnQueue(queue[count]); } for (int count = front; count <= rear; count++) { queue[count] = reverseQueue[count]; } while (!reversedQueueIsEmpty()) { reverseDeQueue(); } } int topElement() // use as stack top element { return queue[rear]; // rear means top value } }; int precedanceCheck(char anOperator) // normal precedency check { if(anOperator == '^') return 3; else if (anOperator == '' || anOperator == '/') return 2; else if (anOperator == '+' || anOperator == '-') return 1; else return 0; } string postfixConverter(string arithmaticExpression) { AQueue aQueue(arithmaticExpression.length()); string postfixedString = ""; for (int count = 0; count < arithmaticExpression.length(); count++) { if ((arithmaticExpression[count] >= '0' && arithmaticExpression[count] <= '9')) postfixedString += arithmaticExpression[count]; //output else if (arithmaticExpression[count] == '(') { aQueue.enQueue('('); } else if (arithmaticExpression[count] == ')') { while (aQueue.topElement() != '(') { postfixedString += aQueue.topElement(); // output aQueue.deQueue(); } aQueue.deQueue(); // delete the starting 1st bracket } else { if(!aQueue.isEmpty()) { while (precedanceCheck(arithmaticExpression[count]) <= precedanceCheck(aQueue.topElement())) { postfixedString += aQueue.topElement(); aQueue.deQueue(); } } aQueue.enQueue(arithmaticExpression[count]); } } while (!aQueue.isEmpty()) { postfixedString += aQueue.topElement(); aQueue.deQueue(); } return postfixedString; } int main() { cout << "THE POSTFIX IS : " << postfixConverter("(5+6/7)*8") << endl; }
